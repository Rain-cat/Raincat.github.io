<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Raincatshine&#39;s  Tree Hole</title>
  
  <subtitle>Life is like a box of colorful chocolates, you never know what the next one is.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-06T15:06:52.922Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mathematical model series 04_图论模型（Dijkstra和Floyd）</title>
    <link href="http://yoursite.com/2020/07/06/Mathematical%20model%20series%2004_%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%EF%BC%88Dijkstra%E5%92%8CFloyd%EF%BC%89/"/>
    <id>http://yoursite.com/2020/07/06/Mathematical%20model%20series%2004_%E5%9B%BE%E8%AE%BA%E6%A8%A1%E5%9E%8B%EF%BC%88Dijkstra%E5%92%8CFloyd%EF%BC%89/</id>
    <published>2020-07-06T11:09:12.283Z</published>
    <updated>2020-07-06T15:06:52.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra-and-Floyd"><a href="#Dijkstra-and-Floyd" class="headerlink" title="Dijkstra and Floyd"></a>Dijkstra and Floyd</h2><p>title: Mathematical model series 04_图论模型（Dijkstra和Floyd）</p><p>date: 2020-07-06 19:09:12<br>Foreword:</p><hr><p>全国研究生数学建模竞赛由教育部学位办与研究生教育发展中心主办，是学位中心主办的“全国研究生创新实践系列活动”主题赛事之一。</p><p>笔者为了准备该项赛事，特意开设这个数模学习系列，督促个人学习。</p><h2 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h2><p><strong>图论模型</strong>是指用图论概括建立的模型，是<strong>研究由线连接的点集</strong>的理论。</p><p>该类模型适用于跟地图相关的实际问题，利用地图上各点的衔接性去求解相应的实际性问题，比如<strong>A地到B地的最低车费、最短路程</strong>等。</p><p>本次，我们一次介绍两种图论算法————<strong>Dijkstra 和 Floyd</strong>。</p><ul><li>Dijkstra </li></ul><p>Dijkstra算法是由Dijkstra于1959年提出，能够求算“地图”上任意一个顶点到另一个顶点的最短路径。</p><p>该算法是一种标号法：给赋权图的每一个顶点记一个数，称为顶点的标号（临时标号，称T标号，或者固定标号，称为P标号）。T标号表示从始顶点到该标点的最短路长的上界；P标号则是从始顶点到该顶点的最短路长。（其实这个最短路长的上界我听着挺懵的，而且他对算法流程的介绍光看文字也很难一下子理清楚，但是结合实例去分析就好很多，所以我们对理论性的内容今天就简单说一下，主要去理解这个算法能够实现的目的）</p><ul><li>Floyd</li></ul><p>Floyd算法是一个经典的动态规划算法，能够寻找从i点到j点的最短路径。</p><p>该算法的过程就是在两点之间的所有点进行搜索，遍历所有的点，通过比较得到最短路径。</p><h2 id="Algorithm-flow"><a href="#Algorithm-flow" class="headerlink" title="Algorithm flow:"></a>Algorithm flow:</h2><ul><li>Dijkstra</li></ul><p>1） 给顶点V1标P标号，d（V1）=0，给顶点Vj（j=2，3，……，n）标T标号d（Vj）=l1j</p><p>2） 在所有T标号中取最小值，譬如，d（Vj0）=l1j0，则把Vj0的T标号改成P标号，并重新计算具有T标号的其他各顶点的T标号：选项Vj的T标号d（Vj）与d（Vj0）+lj0j中较小者作为Vj的新的T标号。</p><p>3） 重复上述步骤，直到目标顶点的标号改成P标号。</p><p>上面这些是小石老师课上给的算法简介，后来我听了他具体的例子之后，就明白了很多，简单来说一下：</p><p><strong>首先</strong>，我们要明确我们的目的，即<strong>从始顶点到终顶点的最短距离</strong>；</p><p><strong>其次</strong>，肯定在任意两点都有不同的权重代表长度，那么我们的任务其实就是，<strong>选出一条路径，使得路径经过的权重值总和最小</strong>。</p><p><strong>同时</strong>，我们规定，<strong>只有我标了固定点的点Vj才有延伸点的资格</strong>，是什么意思呢？比如，初始点A，与他直接相连的点有B、C、D，与B点相连的点有E、F，那么在只规定了A为P的情况下，A点到E、F点的距离就是无穷大，因为他们没有直接接触，但是当我们发现A点到B点的距离最近的时候，我们就可以将B点设为固定点P，那么这个时候<strong>A点到E点的距离=A点到B点的距离+B点到E点的距离</strong>，<strong>A点到F点的距离=A点到B点的距离+B点到F点的距离</strong>，即<em>我们的路径只能经过固定点！</em></p><p><em>经过一个个确定固定点，寻找最短的小路径，最终找到到达终顶点的最短路径，完成算法。</em></p><ul><li>Floyd</li></ul><p>1） 假设<em>Dis（i，j）<em>为节点U到节点V的最短路径的距离，对于每一个节点K，检查</em>Dis（i，k）+Dis（k，j）&lt;Dis（i，j）<em>是否成立，如果成立，则说明i到k再到j的路径比i直接到j的路径短，则设置</em>Dis（i，j）=Dis（i，k）+Dis（k，j）<em>，否则设置</em>Dis（i，j）=Dis（i，j）</em></p><p>2）重复上述操作，直至遍历完所有的节点K</p><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code:"></a>Source code:</h2><ul><li>Dijkstra</li></ul><p>建立函数dijkstra.m</p><pre><code>function [min,path]=dijkstra(w,start,terminal)n=size(w,1); label(start)=0; f(start)=start;for i=1:n   if i~=start       label(i)=inf;end, ends(1)=start; u=start;while length(s)&lt;n   for i=1:n  ins=0;  for j=1:length(s)     if i==s(j)        ins=1;     end,    end  if ins==0     v=i;     if label(v)&gt;(label(u)+w(u,v))        label(v)=(label(u)+w(u,v));      f(v)=u;         end,       end,    end   v1=0;   k=inf;   for i=1:n     ins=0;     for j=1:length(s)        if i==s(j)           ins=1;        end,      end     if ins==0        v=i;        if k&gt;label(v)           k=label(v);  v1=v;        end,       end,     end   s(length(s)+1)=v1;     u=v1;endmin=label(terminal); path(1)=terminal;i=1; while path(i)~=start  path(i+1)=f(path(i));  i=i+1 ;endpath(i)=start;L=length(path);path=path(L:-1:1);</code></pre><p>建立主函数tulunD.m</p><pre><code>disp(&apos;请输入带权邻接矩阵weight（n阶）&apos;);weight=input(&apos;weight=&apos;);   disp(&apos;请输入起点P和终点F&apos;);   P=input(&apos;P=&apos;);   F=input(&apos;F=&apos;);[dis, path]=dijkstra(weight,P, F)    %P为起始点，E为终点，更改此处即可更改始末点</code></pre><ul><li>Floyd</li></ul><p>建立函数floyd.m</p><pre><code>function [D,path,min1,path1]=floyd(a,start,terminal)D=a;n=size(D,1);path=zeros(n,n);for i=1:n   for j=1:n      if D(i,j)~=inf         path(i,j)=j;  end,    end,endfor k=1:n   for i=1:n  for j=1:n     if D(i,k)+D(k,j)&lt;D(i,j)        D(i,j)=D(i,k)+D(k,j);        path(i,j)=path(i,k);     end,   end,    end,endif nargin==3   min1=D(start,terminal);   m(1)=start;   i=1;   path1=[ ];      while   path(m(i),terminal)~=terminal  k=i+1;                                  m(k)=path(m(i),terminal);  i=i+1;   end   m(i+1)=terminal;   path1=m;end   </code></pre><p>建立主函数tulunF.m</p><pre><code>disp(&apos;请输入带权邻接矩阵price（n阶）&apos;);price=input(&apos;price=&apos;);[D, path]=floyd(price)</code></pre><h2 id="Operation-result-analysis"><a href="#Operation-result-analysis" class="headerlink" title="Operation result analysis:"></a>Operation result analysis:</h2><p>为了体现两个算法的异同，我们给两个算法<strong>赋予相同的权重邻接矩阵进行最短路径求解</strong>。</p><p>   [0     8   Inf   Inf   Inf   Inf     7     8   Inf   Inf   Inf;</p><p>   Inf     0     3   Inf   Inf   Inf   Inf   Inf   Inf   Inf   Inf;</p><p>   Inf   Inf     0     5     6   Inf     5   Inf   Inf   Inf   Inf;</p><p>   Inf   Inf   Inf     0     1   Inf   Inf   Inf   Inf   Inf    12;</p><p>   Inf   Inf     6   Inf     0     2   Inf   Inf   Inf   Inf    10;</p><p>   Inf   Inf   Inf   Inf     2     0     9   Inf     3   Inf   Inf;</p><p>   Inf   Inf   Inf   Inf   Inf     9     0   Inf   Inf   Inf   Inf;</p><p>   8   Inf   Inf   Inf   Inf   Inf   Inf     0     9   Inf   Inf;</p><p>   Inf   Inf   Inf   Inf     7   Inf   Inf     9     0     2   Inf;</p><p>   Inf   Inf   Inf   Inf   Inf   Inf   Inf   Inf     2     0     2;</p><p>   Inf   Inf   Inf   Inf    10   Inf   Inf   Inf   Inf   Inf     0;];</p><p>注：其中inf代表无穷大，即不直接接触的两点。</p><ul><li>Floyd</li></ul><p><img src="http://m.qpic.cn/psc?/V12ymZUK0yuzbf/S8ACDDjQaRqj9S24Z8034Z5H2HpSRv8gf4bNpz.KbXbmFMBjhQWs4P.27rYob3PNM9CuzjD7M1F*nC0UFuKQ2A!!/b&bo=QQJcAQAAAAADBzw!&rf=viewer_4" alt=""></p><p><img src="http://m.qpic.cn/psc?/V12ymZUK0yuzbf/YWvjNfAyIVey1fwA2tD8GMNAw.tdpaHnD5cdxZXrQ2PC5DmM2E0PNu9s7XSBT9WRAPjCx7PqO1b0Fcn0dZ4aJUK53PcHnhzn2loZ*T3*cgo!/b&bo=DgKwAgAAAAADF4w!&rf=viewer_4" alt=""></p><p>我们分析该算法的结果：</p><p>其中输出D矩阵是权重矩阵，path为路径。此次，我们寻找的是第1个节点到第11个节点的最短路径。则在path矩阵中找到[1,11]位置，为数字8，说明想要到达11必须先经过8，随后我们找到[1,8]位置，为数字9，说明想要到达11必须经过8→9，找到[1,9]位置，为数字10，找到[1,10]位置，为数字11，则说明此时到达目的地。</p><p>综上，<strong>该算法找到的最短路径为1→8→9→10→11</strong>，<strong>对应的距离权重为D矩阵中[1,11]位置上的值，即21</strong>（此处，小石老师上课好像是说错了，他说的是所经过的所有位置上的权重和，也就是D(1，11)+D(8,11)+D(9,11)+D(10,11)=21+13+4+2=40，这是错的）</p><ul><li>Dijkstra</li></ul><p><img src="http://m.qpic.cn/psc?/V12ymZUK0yuzbf/YWvjNfAyIVey1fwA2tD8GFArOhGOokRk*wVjlwmhUzu2BejDDmPP338XY1BnWNFvs2XQ3EE2wO7vPMwnL31m.JCCGgc9ZE.hEwZtKZWfibQ!/b&bo=QgJ*AQAAAAADFww!&rf=viewer_4" alt=""></p><p><img src="http://m.qpic.cn/psc?/V12ymZUK0yuzbf/YWvjNfAyIVey1fwA2tD8GPukl7*FgmWe4PJy7Moe4tLtViELryHqApu6Ucx.mr1znnVBeKc59eXtMZspGK0sCI6IpjhxfK5p.mwFWgiw9tU!/b&bo=dAHKAAAAAAADF40!&rf=viewer_4" alt=""></p><p>这个算法可以求解矩阵内任意两点之间的最短距离，只需要改变键入的P和F值即可，同时，路径和距离都直接给出，免去了我们自行寻找的过程！（没啥好分析的了，就很直白，就很棒~）</p><p>至此，图论模型的算法的初步认识就结束啦~<br>Tags:</p><hr><p>*<em>Matlab2016b，Mathematical model，Dijkstra and Floyd *</em></p><h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><p><strong>本文所有内容均来自笔者对于小石老师关于数学建模课程的学习笔记，如有需要，请自行购买课程</strong></p><p>如有错误，欢迎大家批评指正！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dijkstra-and-Floyd&quot;&gt;&lt;a href=&quot;#Dijkstra-and-Floyd&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra and Floyd&quot;&gt;&lt;/a&gt;Dijkstra and Floyd&lt;/h2&gt;&lt;p&gt;title:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mathematical model series 03_灰色预测模型（Gray Forecast Model，GFM ）</title>
    <link href="http://yoursite.com/2020/07/03/Mathematical%20model%20series%2003_%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%EF%BC%88Gray%20Forecast%20Model%EF%BC%8CGFM%20%EF%BC%89/"/>
    <id>http://yoursite.com/2020/07/03/Mathematical%20model%20series%2003_%E7%81%B0%E8%89%B2%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%EF%BC%88Gray%20Forecast%20Model%EF%BC%8CGFM%20%EF%BC%89/</id>
    <published>2020-07-03T10:42:48.172Z</published>
    <updated>2020-07-03T12:44:59.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gray-Forecast-Model（GFM）"><a href="#Gray-Forecast-Model（GFM）" class="headerlink" title="Gray Forecast Model（GFM）"></a>Gray Forecast Model（GFM）</h2><p>title: Mathematical model series 03_灰色预测模型（Gray Forecast Model，GFM）</p><p>date: 2020-07-03 18:42:48</p><h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword:"></a>Foreword:</h2><p>全国研究生数学建模竞赛由教育部学位办与研究生教育发展中心主办，是学位中心主办的“全国研究生创新实践系列活动”主题赛事之一。</p><p>笔者为了准备该项赛事，特意开设这个数模学习系列，督促个人学习。</p><h2 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h2><p><strong>灰色预测模型（Gray Forecast Model，GFM）</strong>是基于<strong>少量、不完全信息</strong>的灰色系统，建立的一种数学预测模型，即<strong>对灰色系统的预测</strong>。首先我们来解释一下灰色系统。</p><p>灰色系统是黑箱概念的一种推广。<strong>我们把既含有已知信息，又含有未知信息的系统成为灰色系统</strong>。如果我们考虑极端情况，也就是，整个系统全是已知信息，那么就称其为白色系统，那么相反，整个系统全是未知信息，那么就称其为黑色系统。</p><p>根据马克思主义哲学的思想，人世间万物相联，而灰色预测模型就是利用客观事物在时间上的发展关系，去得到我们所需要了解的“下一步”。</p><p>灰色系统理论是由华中理工大学邓聚龙教授于1982年提出并加以发展的。目前，该理论已成为我国社会、经济、科学技术等诸多领域在进行<strong>预测、决策、评估、规划控制、系统分析与建模时使用的重要方法之一</strong>。</p><p>该方法，是我目前为止（hhhh其实也就第三个），接触的理论上式子最多的，但是好在我们目前只需要大概了解理论内容，然后会自行修改必要代码即可，所以接下来涉及到的理论计算，我都只是放上具体的式子。</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features:"></a>Features:</h2><ol><li><strong>用灰色数学处理不确定量，使之量化</strong></li><li><strong>充分利用已知信息寻求系统的运动规律</strong></li><li><strong>灰色系统理论能处理贫信息系统</strong>（也就是信息量比较少的系统）</li></ol><h2 id="Important-process"><a href="#Important-process" class="headerlink" title="Important process:"></a>Important process:</h2><p>该算法的重点有两个：<strong>灰色生成和GM（1，1）模型</strong></p><p><strong>Part Ⅰ：灰色生成</strong></p><p>生成，即将原始数据列中的数据，<strong>按某种要求作数据处理</strong>。</p><p>世间万物，错综复杂，很难直观地去发现其内在规律，灰色生成的目的就是企图从杂乱无章的表象中去发现内在的规律。</p><p>常用的灰色系统生成方式有：<strong>累加生成</strong>、累减生成、均值生成、级比生成等，本内容以累加生成为主。</p><p>累加生成，即通过数列间各时刻数据的依个累加以后得到新的数据与数列。累加前的数列称原始数列，累加后的数列称为生成数列，该生成是使系统由灰变白的一种方法，该生成数列能够看出灰量积累过程的发展态势，使离乱的原始数据中蕴含的积分特性或规律加以显化。</p><p>说白了，<strong>累加生成就是生成数列X1（i）为原始数列X0前i项和，其中1≤i≤n，n为总的数据量</strong>。</p><p><img src="https://wx3.sinaimg.cn/mw1024/006CJtF1ly1gge13c37kqj30wa0jd76m.jpg" alt=""></p><p><strong>Part Ⅱ：模型GM（1，1）</strong></p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1gge13bz0ukj30w30jmtbw.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw1024/006CJtF1ly1gge13bz59sj30vp0jrq58.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw1024/006CJtF1ly1gge13byrz1j30w60jrta6.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw1024/006CJtF1ly1gge13bz0wvj30vr0hiq48.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1gge13bzk3gj30vg0irmy3.jpg" alt=""></p><p>预测值的求解：</p><p><img src="https://wx3.sinaimg.cn/mw1024/006CJtF1ly1gge13c2rlvj30v605zt8r.jpg" alt=""></p><p>在使用GM（1，1）模型时我们应对其进行精度检测，以此来判定该模型是否能够用来作预测。灰色模型的精度检验一般有三种方法：相对误差大小检验法、关联度检验法和<strong>后验差检验法</strong>。下面我们介绍代码中使用的后验差检验法。</p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1gge13c2btnj30uz06r3zd.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1gge13c3jsaj30vw0iygne.jpg" alt=""></p><p>计算后验差比为：<strong>C=S2/S1</strong></p><p><strong>S1表示原始数据方差</strong>，即原始数据离散程度；<strong>S2表示残方差</strong>，即残差离散程度；<strong>C越小越好</strong>，即S1越大且S2越小，说明尽管原始数据很离散，但是模型所得计算值与实际值之差并不太离散。其中，根据C值得大小来进行精度等级评价，参照表如下图：</p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1gge13bywqmj30q60e740k.jpg" alt=""></p><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code:"></a>Source code:</h2><pre><code>function []=greymodel(y)% 本程序主要用来计算根据灰色理论建立的模型的预测值。% 应用的数学模型是 GM(1,1)。% 原始数据的处理方法是一次累加法。y=input(&apos;请输入数据 &apos;);n=length(y);yy=ones(n,1);yy(1)=y(1);for i=2:n    yy(i)=yy(i-1)+y(i);endB=ones(n-1,2);for i=1:(n-1)    B(i,1)=-(yy(i)+yy(i+1))/2;    B(i,2)=1;endBT=B&apos;;for j=1:n-1YN(j)=y(j+1);endYN=YN&apos;;A=inv(BT*B)*BT*YN;a=A(1);u=A(2);t=u/a;i=1:n+2;yys(i+1)=(y(1)-t).*exp(-a.*i)+t;yys(1)=y(1);for j=n+2:-1:2ys(j)=yys(j)-yys(j-1);endx=1:n;xs=2:n+2;yn=ys(2:n+2);plot(x,y,&apos;^r&apos;,xs,yn,&apos;*-b&apos;);det=0;sum1=0;sumpe=0;for i=1:nsumpe=sumpe+y(i);endpe=sumpe/n;for i=1:n;sum1=sum1+(y(i)-pe).^2;ends1=sqrt(sum1/n);sumce=0;for i=2:nsumce=sumce+(y(i)-yn(i));endce=sumce/(n-1);sum2=0;for i=2:n;sum2=sum2+(y(i)-yn(i)-ce).^2;ends2=sqrt(sum2/(n-1));c=(s2)/(s1);disp([&apos;后验差比值为：&apos;,num2str(c)]);if c&lt;0.35disp(&apos;系统预测精度好&apos;)else if c&lt;0.5    disp(&apos;系统预测精度合格&apos;)else if c&lt;0.65        disp(&apos;系统预测精度勉强&apos;)    else        disp(&apos;系统预测精度不合格&apos;)    endendenddisp([&apos;下个拟合值为 &apos;,num2str(ys(n+1))]);disp([&apos;再下个拟合值为&apos;,num2str(ys(n+2))]);</code></pre><h2 id="Operation-result-analysis"><a href="#Operation-result-analysis" class="headerlink" title="Operation result analysis:"></a>Operation result analysis:</h2><p>对源代码进行运行之后的结果如图所示：</p><p><img src="https://wx3.sinaimg.cn/mw1024/006CJtF1ly1gge2cd08qxj30m50kpab9.jpg" alt=""></p><p>由结果可看出，其C值很小，模型精度符合要求。出图中，蓝色为预测曲线，红色三角形为实际值，可以直观地看出整体偏差是比较小的。</p><p><img src="https://wx3.sinaimg.cn/mw1024/006CJtF1ly1gge2cd00ddj30k50l2dgv.jpg" alt=""></p><p>在这里，我们用的数据更少，而且离散程度比较大，但是模型拟和的情况还是可以哒，C值也比较小，模型精度满足要求。这么少的数据得到这种精确度，总的来说这个预测还是很可的！</p><p>至此，该算法的初步认识结束啦~</p><p>虽然感觉越来越水了，但是该有的知识点我应该没落吧<del>嘿嘿，当作模型初步了解，尚可尚可啦</del><br>Tags:</p><hr><p>*<em>Matlab2016b，Mathematical model，Analytic Hierarchy Process（AHP） *</em></p><h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><p><strong>本文所有内容均来自笔者对于小石老师关于数学建模课程的学习笔记，如有需要，请自行购买课程</strong></p><p>如有错误，欢迎大家批评指正！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Gray-Forecast-Model（GFM）&quot;&gt;&lt;a href=&quot;#Gray-Forecast-Model（GFM）&quot; class=&quot;headerlink&quot; title=&quot;Gray Forecast Model（GFM）&quot;&gt;&lt;/a&gt;Gray Forecast 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mathematical model series 02_多属性决策模型（Multiple-attribute Decision Making Model)</title>
    <link href="http://yoursite.com/2020/07/02/Mathematical%20model%20series%2002_%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B%EF%BC%88Multiple-attribute%20Decision%20Making%20Model)/"/>
    <id>http://yoursite.com/2020/07/02/Mathematical%20model%20series%2002_%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B%EF%BC%88Multiple-attribute%20Decision%20Making%20Model)/</id>
    <published>2020-07-02T14:03:47.028Z</published>
    <updated>2020-07-03T03:18:45.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Multiple-attribute-Decision-Making-Model"><a href="#Multiple-attribute-Decision-Making-Model" class="headerlink" title="Multiple-attribute Decision Making Model"></a>Multiple-attribute Decision Making Model</h2><p>title: Mathematical model series 02_多属性决策模型（Multiple-attribute Decision Making Model）<br>date: 2020-07-02 22:03:47</p><h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword:"></a>Foreword:</h2><p>全国研究生数学建模竞赛由教育部学位办与研究生教育发展中心主办，是学位中心主办的“全国研究生创新实践系列活动”主题赛事之一。</p><p>笔者为了准备该项赛事，特意开设这个数模学习系列，督促个人学习。</p><h2 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h2><p>多属性决策是现代决策科学的一个重要组成部分，可用于工程设计、经济、管理和军事等诸多领域，如<strong>投资决策、项目评估、维修服务、武器系统性能评价、工厂选址、投标招标、产业部门发展排序和经济效益综合评价</strong>等。从它的应用举例上我们可以看出，其应用的场合多为<strong>对一组（有限个）备选方案进行排序或者择优</strong>。这句话是不是乍一看像是个废话？确实，决策就是从备选方案中进行择优选择，我们上一讲的层次分析法也是对备选方案进行择优选择，那相比较于上一讲的层次分析法，多属性决策的不同在哪里呢？继续看！</p><h2 id="Algorithm-flow"><a href="#Algorithm-flow" class="headerlink" title="Algorithm flow:"></a>Algorithm flow:</h2><ul><li><p><strong>获取决策信息</strong></p><p>决策信息一般包括两方面内容：<strong>属性权重和属性值</strong>（属性值主要有三种形式：实数、区间数和语言）。这里的<strong>属性值说白了就是我在某一个量纲下赋予不同备选方案同一个属性的数值大小</strong>，也可以<strong>再说白点就是这个属性的得分</strong>吧。属性权重，权重！再次出现！层次分析法中，权重是决定方案的关键因素，这里，它也很重要，也是能够决定最终排序的关键因素，怎么决定呢？继续看继续看~</p><p><strong>首先，我们要获取属性值。</strong></p><p> 属性值的初始值一般是给出的（因为这就是对方案进行某个属性的打分），所以不做讨论。</p><p> <strong>随后，对属性值进行归一化处理。</strong></p><p> 属性类型一般有效益型、成本型、固定型、偏离型、区间型、偏离区间型等。其中，效益型是指属性值越大越好，成本型相反；固定型是指离固定值越近越好，偏离型相反；区间型是指越接近给定区间越好，偏离区间型相反。</p><p> 在实际问题中，由于物理量纲不同，在信息集结时会造成权重时同一个量纲但是属性值不是同一个量纲，进而影响最终的决策。</p></li></ul><p>   <em>比如，A属性满分100，B属性满分为1，那么在进行集结时需要乘以相应的权重，但此时，就算B属性给了满分1，在整个项目中也显得微乎其微甚至可以忽略，从而影响结果。</em></p><p>   对此，我们需要对属性值进行归一化处理，根据不同类型，我们有不同的归一化算法。</p><p><strong>效益型：</strong></p><p><img src="https://images2018.cnblogs.com/blog/1226694/201807/1226694-20180711221443329-1091730485.gif" alt=""></p><p><strong>成本型：</strong></p><p><img src="https://images2018.cnblogs.com/blog/1226694/201807/1226694-20180711222141687-399558068.gif" alt=""></p><p><strong>固定型：</strong></p><p> <img src="https://images2018.cnblogs.com/blog/1226694/201807/1226694-20180711222953069-708788758.gif" alt=""></p><p><strong>偏离型：</strong></p><p><img src="https://images2018.cnblogs.com/blog/1226694/201807/1226694-20180711222804394-629204973.gif" alt=""></p><p><strong>区间型：</strong></p><p><img src="https://images2018.cnblogs.com/blog/1226694/201807/1226694-20180711224501361-516685121.gif" alt=""></p><p><strong>偏离区间型：</strong></p><p>rij=1-rij（区间型）</p><p><strong>最后，获取属性权重。</strong></p><p> 属性权重的获取与上一讲层次分析法中一致，即利用成对比较矩阵来获取五个属性的权重，此处不再赘述，详情请参考上一讲。</p><ul><li><p><strong>对决策信息进行集结并对方案进行排序和择优</strong></p><p> 当我们获得了属性权重和归一化后的属性值，就可以进行集结和排序了。   </p><p> <strong>首先，信息集结。</strong></p><p> 信息集结的方法很多，但是我们主要学习的是较为常用的<strong>加权算术平均算子WAA</strong>。</p><p> 设函数<em>WAA：Rn→R，（a1，a2，……，an）是一组给定的数据，若WAAω（a1，a2，……，an）=∑ωjaj（其中下标j由1到n）</em></p><p> 其中，<em>ω=（ω1，ω2，……，ωn）T<em>（T为上标）是数据组</em>（a1，a2，……，an）*的权重向量，且取值为</em>[0,1] 1≤j≤n <em>所有ω的和为1，R为实数集，因此称函数WAA为*</em>加权算术平均算子（Weighted arithmetic averaging（WAA）operator）**。</p><p> 式子看起来一团乱麻，但事实上非常简单！</p><p> *比如：火影学院的教学水平评估中有4项指标：办学知道思想、学风、教学效果和特色项目，得分分别为A、B、C、D，4项指标的权重分别为a、b、c、d，构成向量ω，则加权平均综合得分即为：</p><p> WAAω（A、B、C、D）=A×a+B×b+C×c+D×d*</p><p> <strong>最后，对每个备选方案计算的WAA进行排序，得到最优方案选择序列。</strong></p></li></ul><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code:"></a>Source code:</h2><p> <em>本讲所涉及的代码仅有权重计算的代码，如需，请从笔者博客首页移步至github，代码放置在“Code_math”仓库中。</em></p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h2><p><img src="https://img-blog.csdnimg.cn/20190129135438893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6aHVvcWlu,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20190129135458443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6aHVvcWlu,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20190129135518677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6aHVvcWlu,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://img-blog.csdnimg.cn/20190129135535797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6aHVvcWlu,size_16,color_FFFFFF,t_70" alt=""></p><p>（图片均来自小石老师课堂示例，侵删）</p><p>通过计算，企业1-4的得分分别为：0.8 0.79 0.89 0.85</p><p>所以，应该投资企业3，随后考虑企业4.</p><p>至此，该算法的初步认识结束啦~</p><p>不知道大家现在能不能领悟到层次分析法和该方法的异同了，就我个人而言的话，只可意会不可言传？hhhhh</p><h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags:"></a>Tags:</h2><p>*<em>Matlab2016b，Mathematical model，Multiple-attribute Decision Making Model *</em></p><h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><p><strong>本文所有内容均来自笔者对于小石老师关于数学建模课程的学习笔记，如有需要，请自行购买课程</strong></p><p>如有错误，欢迎大家批评指正！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Multiple-attribute-Decision-Making-Model&quot;&gt;&lt;a href=&quot;#Multiple-attribute-Decision-Making-Model&quot; class=&quot;headerlink&quot; title=&quot;Multiple-att
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mathematical model series 01_层次分析法（Analytic Hierarchy Process，AHP）</title>
    <link href="http://yoursite.com/2020/06/30/Mathematical%20model%20series%2001_%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%88Analytic%20Hierarchy%20Process%EF%BC%8CAHP%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/30/Mathematical%20model%20series%2001_%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%88Analytic%20Hierarchy%20Process%EF%BC%8CAHP%EF%BC%89/</id>
    <published>2020-06-30T09:16:01.225Z</published>
    <updated>2020-06-30T13:12:08.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Analytic-Hierarchy-Process（AHP）"><a href="#Analytic-Hierarchy-Process（AHP）" class="headerlink" title="Analytic Hierarchy Process（AHP）"></a>Analytic Hierarchy Process（AHP）</h2><p>title: Mathematical model series 01_层次分析法（Analytic Hierarchy Process，AHP）</p><p>date: 2020-06-30 17:16:01</p><h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword:"></a>Foreword:</h2><p>全国研究生数学建模竞赛由教育部学位办与研究生教育发展中心主办，是学位中心主办的“全国研究生创新实践系列活动”主题赛事之一。</p><p>笔者为了准备该项赛事，特意开设这个数模学习系列，督促个人学习。</p><p>突然发现今天是6.30，2020上半年的最后一天，也算为我碌碌无为的上半年加点料吧~</p><p>2020下半年旋风开启，flag不许再倒！</p><h2 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information:"></a>Basic Information:</h2><p>层次分析法（AHP）是美国运筹学家皮茨堡大学教授萨蒂（T.L.Santy）于上世纪70年代初，为美国国防部研究“根据各个工业部门对国家福利的贡献大小而进行电力分配”课题时，应用网络系统理论和多目标综合评价方法，提出的一种<strong>层次权重决策方法</strong>。</p><p>根据这个基本的介绍，其实就可以对这种方法做一个简单的认识，即<strong>该方法最终影响决策的方式是其算法所分配的最终权重</strong>。</p><p>同时，该方法的<strong>特点</strong>是在对复杂问题本质、影响因素及内在关系具有了一定的了解之后，利用较少的定量信息使得决策的思维过程数学化，从而对多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法。</p><p>简言之，该方法适用于对于<strong>决策目标Z</strong>有<strong>i个影响因素，分别为Ai</strong>和<strong>n个备选方案，分别为Bn</strong>的情况。</p><h2 id="Algorithm-flow"><a href="#Algorithm-flow" class="headerlink" title="Algorithm flow:"></a>Algorithm flow:</h2><ol><li><strong>建立层次结构模型</strong></li><li><strong>构造判断（成对比较）矩阵</strong></li><li>层次单排序及其一致性检验</li><li>层次总排序及其一致性检验</li></ol><p>其中，主要过程为<strong>1.和2.</strong>两步，第3.和4.主要是理论解释，此处不再做解释，有兴趣的读者可以自行阅读相关文献。</p><ul><li><p><strong>建立层次结构模型（本文以旅游问题为例）</strong></p><p>  该过程需要对所遇到的问题进行基本的认识，即<strong>找到目标或解决的问题Z、影响因素或者决策准则Ai以及决策备选方案Bn</strong>，依次设为最高层、中间层和最底层。</p><p>  本文旅游目的地选择为Z，景色、费用、居住、饮食、旅途为5个影响因素，分别设为A1、A2、A3、A4、A5，α星球、β星球、γ星球为3个备选方案，分别设为B1、B2、B3。</p></li></ul><p><img src="https://wx3.sinaimg.cn/mw1024/006CJtF1ly1ggaktiut8rj30ab07u75e.jpg" alt=""></p><pre><code>此时，我们已经将所要解决的问题转化成了数学结构模型，可以进行下一步，**构造成对比较矩阵**。</code></pre><ul><li><p><strong>构造成对比较矩阵</strong></p><p>  该过程对于整个算法至关重要。</p><p>  <strong>成对比较矩阵是对于该层次相对于上层次的重要程度而言的</strong>，即Ai一层对于Z一层的重要程度构成成对比较矩阵P（由于上层只有一个目标，则此处仅有一个矩阵P1），Bn一层对于Ai一层的重要程度构成成对比较矩阵Pn（由于上层有5个影响因素，则此时有5个矩阵，P1、P2、P3、P4、P5）。</p></li></ul><p>   成对比较矩阵，顾名思义是两两进行比较，具体值的大小参考成对比较阵标度表。</p><p><img src="https://wx3.sinaimg.cn/mw1024/006CJtF1ly1ggaky2cipoj30w00j7qj6.jpg" alt=""></p><p>   下面以矩阵P为例进行解释：</p><p>   P=</p><pre><code>[   1,  1/2,  4,     3,      3;    2,  1  ,  7,     5,      5;  1/4,  1/7,  1,   1/2,    1/3;  1/3,  1/5,  2,     1,      1;  1/3,  1/5,  3,     1,      1;]</code></pre><p>矩阵中，P11代表A1与A1相比的重要程度，根据标度表可知，两者对于最终目的Z而言同等重要，且对应的Pii的位置必须均为1，P12为A1与A2相比的重要程度，根据标度表可知，A2比A1对于最终目的Z而言稍微重要，以此类推。</p><p>那么这个矩阵怎么来的呢？</p><p>原则上，该矩阵应由专家评委给出，但<strong>在实际数模大赛中，需要自行判断</strong>！</p><p>它的重要性体现在哪呢？</p><p>由前面我们知道，这个算法的最终决策准则是根据权重来的，而这个矩阵就是算法中需要进行计算的原始数据，需要我们自行填入，所以，一招不慎，满盘皆输啊！</p><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code:"></a>Source code:</h2><pre><code>disp(&apos;请输入判断矩阵A（n阶）&apos;);A=input(&apos;A=&apos;);[n,n]=size(A);x=ones(n,100);y=ones(n,100);m=zeros(1,100);m(1)=max(x(:,1));y(:,1)=x(:,1);x(:,2)=A*y(:,1);m(2)=max(x(:,2));y(:,2)=x(:,2)/m(2);p=0.0001;i=2;k=abs(m(2)-m(1));while k&gt;pi=i+1;x(:,i)=A*y(:,i-1);m(i)=max(x(:,i));y(:,i)=x(:,i)/m(i);k=abs(m(i)-m(i-1));enda=sum(y(:,i));w=y(:,i)/a;t=m(i);disp(w);%以下是一致性检验CI=(t-n)/(n-1);RI=[0 0 0.52 0.89 1.12 1.26 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59];CR=CI/RI(n);if CR&lt;0.10disp(&apos;此矩阵的一致性可以接受！&apos;);disp(&apos;CI=&apos;);disp(CI);disp(&apos;CR=&apos;);disp(CR);end</code></pre><h2 id="Operation-result-analysis"><a href="#Operation-result-analysis" class="headerlink" title="Operation result analysis:"></a>Operation result analysis:</h2><p>对源代码进行运行之后的结果如图所示：</p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1ggaktiw9osj30nl0eu0st.jpg" alt=""></p><p><strong>图中输出数据0.2636  0.4758  0.0538  0.0981  0.1087是该算法的重要数据，分别为影响因素景色、费用、居住、饮食、旅途对目的地选择的影响权重。</strong></p><p>同理，输入成对比较矩阵P1、P2、P3、P4、P5之后，得到三个选择地分别对五个影响因素的影响权重。得到结果如下如所示：</p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1ggaktiye4ij30lj0dgn5t.jpg" alt=""></p><p>得到两级权重之后，需要对三个目的地的最终权重进行计算。</p><p><strong>B1对总目标的权重值=B1对A1的权重×A1对Z的权重+B1对A2的权重×A2对Z的权重……+B1对A5的权重×A5对Z的权重</strong></p><p>计算结果如图所示：</p><p><img src="https://wx2.sinaimg.cn/mw1024/006CJtF1ly1ggaktizbnoj30t20dr479.jpg" alt=""></p><p><strong>得到三个目的地对总目标的权重之后进行大小排序</strong>，我们可以得到：</p><p>γ星球权重&gt;α星球权重&gt;β星球权重，所以，本次出游优先选择目的地为γ星球。</p><p>至此，该算法的初步认识结束啦~<br>Tags:</p><hr><p>*<em>Matlab2016b，Mathematical model，Analytic Hierarchy Process（AHP） *</em></p><h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><p><strong>本文所有内容均来自笔者对于小石老师关于数学建模课程的学习笔记，如有需要，请自行购买课程</strong></p><p>如有错误，欢迎大家批评指正！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Analytic-Hierarchy-Process（AHP）&quot;&gt;&lt;a href=&quot;#Analytic-Hierarchy-Process（AHP）&quot; class=&quot;headerlink&quot; title=&quot;Analytic Hierarchy Process（AHP
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
